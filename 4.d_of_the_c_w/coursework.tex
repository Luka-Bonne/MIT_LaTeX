\documentclass[bachelor, och, coursework]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{tempora}

%\usepackage{minted}
\usepackage[colorlinks=true]{hyperref}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{ЛЕКСИЧЕСКИЙ И СИНТАКСИЧЕСКИЙ АНАЛИЗ ВЫРАЖЕНИЙ}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Рыданова Никиты Сергеевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент} %должность, степень, звание
\saname{Г.\,Г.\,Наркайтис}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{к.\,ф.-м.\,н., доцент}
\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.07.2016}
\practFinish{14.07.2016}

% Год выполнения отчета
\date{2021}
\maketitle
\setcounter{tocdepth}{3}
\tableofcontents 

\section{Абстрактные синтаксические деревья}
    \subsection{Управление памятью на основе регионов}
    \subsubsection{Мотивировка}
    
    Текущая реализация абстрактного синтаксического дерева имеет следующие недостатки:
    \begin{enumerate}
    \item Выделение памяти стандартным методом может значительно фрагментировать оперативную память, 
    затрудняя доступ к ней.
    \item Любое выделение и удаление памяти требует вмешательства системных
    вызовов, что может стать причиной дополнительных издержек во время
    работы программы.
    \item Программист не имеет возможности ручного управления выделяемой им
    памятью.
    \end{enumerate}

    Избавиться от этих недостатков можно используя различные оптимизации. В рамках этой работы 
    воспользуемся управлением памятью на основе, так называемых, регионов (арен, зон)\cite{Wang}.

    Под регионом далее будем понимать непрерывную область памяти, содержащую внутри себя объекты. 
    При запуске программы выделим регион некоторого размера, при необходимости увеличивая его 
    размер в некоторое постоянное число раз.

    Этот подход имеет следующие преимущества:
    \begin{enumerate}
        \item Элементы располагаются последовательно, в связи с чем минимизируется
        фрагментация и упрощается доступ к объектам.
        \item Выделение и освобождение памяти выполняется с минимальными издержками.
        \item Программисту предоставляется большая свобода для управления выделенной памятью.
    \end{enumerate}

    \subsubsection{Построение}
    Формально определим требования к системе:
    \begin{enumerate}
        \item Регион должен представлять из себя некоторый непрерывный участок размера $n$ байт 
        (в начальный момент времени размер равен некоторой начальной величине $n_0$).
        \item При обращении к региону он должен предоставить $k$ байт памяти и вернуть
        некоторый идентификатор этого участка для последующего обращения.
        \item При заполнении региона должна быть возможность увеличить объем доступной памяти в 
        некоторое число раз, которое далее будем называть
        коэффициентом увеличения.
        \item Должна быть доступна возможность эффективного освобождения всей
        выделенной регионом памяти.
    \end{enumerate}
    Единственной сложной операцией над регионом является его увеличение. 
    Так как выделение нового участка потенциально может сопровождаться изменением адресов объектов, 
    то необходимо организовать доступ к ним независимо от первоначального адреса. Для этого для 
    каждого объекта будем получать доступ к нему через некоторый индекс.

    Кроме того, коэффициент увеличения должен быть выбран таким образом, чтобы был соблюден баланс 
    между оптимальным объемом выделенной памяти и частотой системных вызовов.

    \subsubsection{Определение структуры}
    Определим нашу структуру следующим образом:
    
    %файл питона

    \subsubsection{Инициализация}
    Теперь определим функцию arena\_construct, выполняющую начальную инициализацию состояния региона:
    %файл питона

    \subsubsection{Выделение памяти}
    После выделения некоторого объема памяти возможно обращение к ней.
    Определим это обращение с помощью функции arena\_allocate:
    %файл питона

    Отметим, что наиболее часто значением MULTIPLY\_FACTOR оказывается числа 
    1.5 и 2. Это позволяет достичь амортизационно константного времени 
    выполнения операции выделения памяти \cite{Facebook}.

    \subsubsection{Освобождение выделенной памяти}
    Наконец, реализуем освобождение выделенной региону памяти с помощью функции arena\_free
    %файл питона

    \subsubsection{Модификация абстрактного синтаксического дерева}
    Осталось изменить исходный код программы, чтобы обеспечить выделение памяти с помощью полученной 
    нами структуры данных.

    Для этого воспользуемся директивой \%param и заявим в качестве параметра переменную типа arena*. 
    В функциях eval, newnum, newast внесем изменения, чтобы обеспечить выделение памятью с помощью 
    написанных ранее функций.

    С полным кодом программы можно ознакомиться в приложении А.%ссылка

    \subsubsection{Сборка проекта}
    Теперь проект можно собрать, незначительно изменив Makefile:
    %файл питона
    и запустить. Результат работы программы представлен на рис. \hyperref[6]{6} 

    \begin{center}
        \includegraphics[scale=0.6]{pics/naivetest.png}\\
        {\small Рисунок 6 – Демонстрация работы программы}\label{6}
    \end{center}

    \section{Сравнение полученных реализаций}
    Проведем анализ производительности полученных версий анализатора. В 
    качестве данных для тестирования возьмем выражения вида $\underbrace{2 + 2 + 2 \dots + 2}_n $ 
    для $n = 1 \dots 100$ с шагом 1. Для вычисления времени выполнения воспользуемся библиотекой 
    time Python 3.9.5. Автоматизацию обеспечим с помощью библиотеки subprocess. Получим следующий код:
    %файл питона

    Кроме того, отметим, что в ранее написанные программы были внесены некоторые изменения для 
    проведения эксперимента. Ознакомиться с ними можно в приложении А.%ссылка

    Ознакомиться с полным исходным кодом программы, осуществляющей 
    исследование производительности можно в приложении Б.%ссылка

    Для большей наглядности графики интерполированы полиномом с помощью функции polyfit библиотеки numpy.

    Ознакомиться с полным исходным кодом программы, осуществляющей 
    анализ полученных результатов можно в приложении В.%ссылка

    Результаты исследования изображены на рис. \hyperref[7]{7}:

    \begin{center}
        \includegraphics[scale=0.4]{pics/benchmark.png}\\
        {\small Рисунок 7 – Сравнение полученных результатов}\label{7}
    \end{center}

    Исследование показало, что использование абстрактных синтаксических деревьев позволяет уменьшить время 
    работы программы более чем в 5 раз, что существенно заметно для выражений любой длины.

    Также из графиков видно, что в рамках данной работы не удалось добиться большей производительности при 
    управлении памятью на основе регионов. Тем не менее, она все еще может считаться более предпочительной 
    ввиду перечисленных ранее преимуществ.

    \begin{thebibliography}{7}
        \bibitem{Wang} Wang, D.~C."~A. Managing memory with types / D.~C."~A.~Wang. "--- Princeton
        University, 2002. "--- Pp. 29"~55.
        \bibitem{Facebook} Facebook open"~source library documentation [Электронный ресурс]. "---
        URL: \href{https://github.com/facebook/folly/blob/master/folly/docs/}{https://github.com/facebook/folly/blob/master/folly/docs/}
        \href{https://github.com/facebook/folly/blob/master/folly/docs/}{FBVector.md} (Дата обращения 25.05.2021). Загл. с экр. Яз. англ.
    \end{thebibliography}
    \signatureline

\end{document}
